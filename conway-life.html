<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>conway-life</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Lora&display=swap"
      rel="stylesheet"
    />
    <style>
      #heading {
        font-family: "Lora", serif;
      }
    </style>
  </head>
  <body>
    <h1 id="heading">Conway's Game of Life</h1>
    <div class="board"></div>
    <div class="buttons">
      <button type="button" name="nextRound">下一轮</button>
      <button type="button" name="auto">自动演化</button>
      <button type="button" name="stop">停止演化</button>
      <button type="button" name="random">随机</button>
      <button type="button" name="clear">清空</button>
    </div>

    <script>
      "use strict";
      let NUM_OF_ROWS;
      let NUM_OF_COLS;
      let TOTAL_NUMBER_OF_CELLS;
      let INITIAL_NUMBER_OF_LIVING_CELLS = 20;
      let gridArray;
      let currentStateArray;
      let nextStateArray;
      let animationID;
      let period = 300;
      const randomButton = document.querySelector('button[name="random"]');
      const nextRoundButton = document.querySelector(
        'button[name="nextRound"]'
      );
      const autoButton = document.querySelector('button[name="auto"]');
      const stopButton = document.querySelector('button[name="stop"]');
      const clearButton = document.querySelector('button[name="clear"]');
      const board = document.querySelector(".board");

      /**
       * 初始化屏幕上面的棋盘（默认10行10列）
       * @param {number} rows
       * @param {number} cols
       */
      function initializeCheckboxes(rows = 10, cols = 10) {
        if (!isNaN(rows) && !isNaN(cols)) {
          rows = Math.abs(Number(rows.toFixed(0)));
          cols = Math.abs(Number(cols.toFixed(0)));
        } else {
          rows = 10;
          cols = 10;
        }

        NUM_OF_ROWS = rows;
        NUM_OF_COLS = cols;
        TOTAL_NUMBER_OF_CELLS = NUM_OF_ROWS * NUM_OF_COLS;
        for (let i = 0; i < rows; i++) {
          const row = document.createElement("div");
          row.setAttribute("data-row", `${i}`);
          makeOneRowOfCheckboxes(row, i, NUM_OF_COLS);
          board.appendChild(row);
        }
      }

      /**
       * 初始化「一行」checkbox
       * @param {HTMLDivElement} elementNode
       * @param {number} row
       * @param {number} cols
       */
      function makeOneRowOfCheckboxes(elementNode, row, cols) {
        for (let i = 0; i < cols; i++) {
          const checkbox = document.createElement("input");
          checkbox.setAttribute("type", "checkbox");
          checkbox.setAttribute("data-row", `${row}`);
          checkbox.setAttribute("data-col", `${i}`);
          elementNode.appendChild(checkbox);
        }
      }

      /**
       * 初始化 gridArray 变量
       */
      function makeGrid() {
        const grid = document.querySelectorAll(".board > [data-row]");
        gridArray = Array.from(grid);

        for (let i = 0; i < gridArray.length; i++) {
          gridArray[i] = Array.from(gridArray[i].children);
        }
      }

      /**
       * 重置整个棋盘，亦即把网页上所有的框都取消勾选
       */
      function resetCheckedCheckboxes() {
        for (let i = 0; i < gridArray.length; i++) {
          for (let j = 0; j < gridArray[i].length; j++) {
            gridArray[i][j].checked = null;
          }
        }
      }

      /**
       * 在区间 [lo, hi) 中随机抽取 k 个整数
       * @param {number} lo
       * @param {number} hi
       * @param {number} k
       * @return {number[]}
       */
      function sample(lo, hi, k) {
        const res = [];

        for (let i = 0; i < k; i++) {
          res[i] = lo + i;
        }

        let i = k;

        while (i < hi - lo) {
          i++;
          const j = Math.floor(Math.random() * i);

          if (j < k) {
            res[j] = lo + i - 1;
          }
        }

        return res;
      }

      /**
       * 将被选中的下标对应的checkbox选中
       * @param {number[]} indices
       */
      function chooseLivingCells(indices) {
        for (let index of Object.values(indices)) {
          gridArray[Math.floor(index / gridArray[0].length)][
            index % gridArray[0].length
          ].checked = "checked";
        }
      }

      /**
       * 先重置棋盘，然后随机抽样，把被抽中的checkbox勾选上
       */
      function randomlySelectCheckboxes() {
        resetCheckedCheckboxes();
        chooseLivingCells(
          sample(0, TOTAL_NUMBER_OF_CELLS, INITIAL_NUMBER_OF_LIVING_CELLS)
        );
      }

      /**
       * 按照棋盘的状态生成currentStateArray
       */
      function makeCurrentStateArray() {
        currentStateArray = [];
        let currentRowState = [];
        for (let i = 0; i < gridArray.length; i++) {
          for (let j = 0; j < gridArray[i].length; j++) {
            currentRowState[j] = Boolean(gridArray[i][j].checked) ? 1 : 0;
          }
          currentStateArray.push(currentRowState.slice());
          currentRowState = [];
        }
      }

      /**
       * 生成全部为0的nextStateArray
       */
      function generateDefaultNextStateArray() {
        nextStateArray = [];
        const row = Array(gridArray[0].length).fill(0);

        for (let i = 0; i < gridArray.length; i++) {
          nextStateArray.push(row.slice());
        }
      }

      /**
       * 计算一个checkbox周围正在存活的邻居数量
       * @param {number} row
       * @param {number} col
       * @return {number} numOfLivingNeighbors
       */
      function getNumberOfLivingNeighbors(row, col) {
        const neighbors = [];
        neighbors[0] = currentStateArray[row - 1]?.[col - 1] ?? 0;
        neighbors[1] = currentStateArray[row - 1]?.[col] ?? 0;
        neighbors[2] = currentStateArray[row - 1]?.[col + 1] ?? 0;
        neighbors[3] = currentStateArray[row][col + 1] ?? 0;
        neighbors[4] = currentStateArray[row + 1]?.[col + 1] ?? 0;
        neighbors[5] = currentStateArray[row + 1]?.[col] ?? 0;
        neighbors[6] = currentStateArray[row + 1]?.[col - 1] ?? 0;
        neighbors[7] = currentStateArray[row][col - 1] ?? 0;

        const numOfLivingNeighbors = neighbors.reduce((prev, curr) => {
          return prev + curr;
        }, 0);

        return numOfLivingNeighbors;
      }

      /**
       * 按照游戏规则，将符合要求的nextStateArray中的格子变成1
       * @param {number} num
       * @param {number} i
       * @param {number} j
       */
      function flipStatesBasedOnTheRule(num, i, j) {
        if (num === 3) {
          nextStateArray[i][j] = 1;
        } else if (num === 2 && currentStateArray[i][j] === 1) {
          nextStateArray[i][j] = 1;
        }
      }

      /**
       * 遍历整个棋盘，使得nextStateArray的所有格子完全符合规则
       */
      function chooseLivingCellsBasedOnNeighbors() {
        for (let i = 0; i < NUM_OF_ROWS; i++) {
          for (let j = 0; j < NUM_OF_COLS; j++) {
            const num = getNumberOfLivingNeighbors(i, j);
            flipStatesBasedOnTheRule(num, i, j);
          }
        }
      }

      /**
       * 按照流程和游戏规则，生成表示下一个棋盘状态的nextStateArray
       */
      function generateNextStateArray() {
        makeCurrentStateArray();
        generateDefaultNextStateArray();
        chooseLivingCellsBasedOnNeighbors();
      }

      function nextRoundGrid() {
        generateNextStateArray();
        resetCheckedCheckboxes();

        for (let i = 0; i < NUM_OF_ROWS; i++) {
          for (let j = 0; j < NUM_OF_COLS; j++) {
            if (nextStateArray[i][j] === 1) {
              gridArray[i][j].checked = "checked";
            }
          }
        }
      }

      function automaticallyEvolve(time) {
        if (animationID == undefined) {
          animationID = setInterval(nextRoundGrid, time);
        }
      }

      function stopautomaticallyEvolve() {
        if (animationID != undefined) {
          clearInterval(animationID);
          animationID = undefined;
        }
      }

      initializeCheckboxes();
      window.addEventListener("DOMContentLoaded", makeGrid);
      randomButton.addEventListener("click", randomlySelectCheckboxes);
      nextRoundButton.addEventListener("click", nextRoundGrid);
      autoButton.addEventListener("click", function outerautomaticallyEvolve() {
        automaticallyEvolve(period);
      });
      stopButton.addEventListener("click", stopautomaticallyEvolve);
      clearButton.addEventListener("click", function clearTheBoard() {
        stopautomaticallyEvolve();
        resetCheckedCheckboxes();
      });
    </script>
  </body>
</html>
